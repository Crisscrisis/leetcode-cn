## leetcode53 最大子序和

### 思路
```
示例: [a, b , c, d , e]
通常我们遍历子串或者子序列有三种遍历方式：
以某个节点为开头的所有子序列: 如 [a],[a, b],[ a, b, c] ... 再从以 b 为开头的子序列开始遍历 [b] [b, c]。
根据子序列的长度为标杆,如先遍历出子序列长度为 1 的子序列,在遍历出长度为 2 的 等等。
以子序列的结束节点为基准,先遍历出以某个节点为结束的所有子序列,因为每个节点都可能会是子序列的结束节点,因此要遍历下整个序列,如: 以 b 为结束点的所有子序列: [a , b] [b] 以 c 为结束点的所有子序列: [a, b, c] [b, c] [ c ]。
第一种遍历方式通常用于暴力解法, 第二种遍历方式 leetcode (5. 最长回文子串 ) 中的解法就用到了。

第三种遍历方式 因为可以产生递推关系, 采用动态规划时, 经常通过此种遍历方式, 如 背包问题, 最大公共子串 , 这里的动态规划解法也是以 先遍历出 以某个节点为结束节点的所有子序列 的思路

对于刚接触动态规划的, 第三种遍历方式是需要抓住的核心

因为我们通常的惯性思维是以子序列的开头为基准，先遍历出以 a 为开头的所有子序列，再遍历出以 b 为开头的...但是动态规划为了找到不同子序列之间的递推关系，恰恰是以子序列的结束点为基准的，这点开阔了我们的思路。

故此题中，dp[i]表示，以i位置为结尾的所有子串的最大值：
若dp[i-1]<0，则i之前的子串对dp[i]的大小贡献为负，故需要舍弃,而nums[i]必须要选（因为是以i位置结尾,故为dp[i-1] + nums[i]；
若dp[i-1]>0,则i之前的子串对dp[i]的大小贡献为正,所以需要加上,而nums[i]必须要选（因为是以i位置结尾）,故为dp[i-1] + nums[i]
```

### code
```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if (nums.empty()) {
            return 0;
        }
        vector<int> dp; // dp[i]:the max value of subarray which ends in position of i
        dp.push_back(nums[0]);
        int max = dp[0];
        for (int i = 1; i < nums.size(); i++) {
            if (dp[i - 1] < 0) {
                dp.push_back(nums[i]);
            } else {
                dp.push_back(dp[i - 1] + nums[i]);
            }
            if (max < dp[i]) {
                max = dp[i];
            }
        }
        return max;
    }
};
```